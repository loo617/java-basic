# 垃圾收集
***
目的排查和监控内存溢出和内存泄漏问题。
## 判断对象存活

### 引用计数法
每当有引用的地方，计数器值就加1。当引用失效时，计数器值就减1。缺点：无法解决循环引用的问题。
### 可达性分析算法
是否关联根节点GC Roots
### 引用
引用有四种类别：**强引用**,**软引用**,**弱引用**,**虚引用**。
- 强引用：例如直接new对象，不管内存够不够都不会被回收。
- 软引用: 使用SoftReference类来表示，内存不足时会被回收，一般用来实现缓存。
- 弱引用: 使用WeakReference类表示，无论内存充不充足，只要此时进行垃圾回收都会被回收掉。
- 虚引用：使用WeakReference类表示，理解为最弱的一种引用关系。

### 整体流程


```flow
st=>start: 开始
op1=>operation: 可达性分析
op2=>operation: 垃圾收集
op3=>operation: 执行finalize方法
op4=>operation: 垃圾收集
cond=>condition: 是否覆盖finalize方法
e=>end: 结束

st->op1->cond
cond(yes)->op4->op3->e
cond(no)->op2->e
```

## 垃圾收集算法

### 标记-清除算法
将需要标记的需要清理的内存直接清理。缺点：剩下的内存不是连续的，当需要分配较大对象时需要再触发一次gc。
### 复制算法
将内存分为大小相等的两块，每次只用一块，把存活的复制到另一块，然后清除。
### 标记-整理算法
在标记-清除算法的基础上将存活对象全部移动到一端。
### 分代收集算法
新生代使用复制算法，老年代使用标记-清除和标记-整理算法。

## 垃圾收集器
根据内存的区域可以分为针对新生代的垃圾收集器和针对老年代的垃圾收集器。

### 新生代垃圾收集器
| 收集器名称 | 特点 | 所用参数 |
| ------ | ------ | ------ | 
| Serial | 单线程，采用复制算法，适用于单个CPU的用户桌面场景  | -XX:SurvivorRatio:内存分配比例 |
| ParNew | 其实是Serial的多线程版，采用复制算法，在多核cpu下性能优于Serial | -XX:SurvivorRatio:内存分配比例<br>-XX:ParallelGCThreads:线程数 |
| Parallel | 多线程，采用复制算法，关注点在于可控制的吞吐量，所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗的时间比值|-XX:MaxGCPauseMillis:最大停顿时间<br>-XX:GCTimeRatio：设置吞吐量 |
| G1| 充分利用cpu,分代收集，使用标记整理算法，可预测的停顿 ||

### 老年代垃圾收集器
| 收集器名称 | 特点 | 所用参数 |
| ------ | ------ | ------ | 
| CMS | 采用标记-清除算法，为了获取最短停顿时间<br>4个步骤：初始标记、并发标记、重新标记、并发清除,其中初始和并发标记仍然stop the world。重新标记是为了修正<br>缺点：并发的设计导致程序慢，并发的设计导致Concurrent Mode Failure,标记-清除的限制导致可能不能分配大对象 |  |
| Serial Old | Serial的老年代版，也是单线程，采用标记-整理算法，适用于单个CPU的用户桌面场景或者JDK1.5以前的服务端 |  |
| Parallel Old | Parallel的老年代版，多线程，采用标记-整理算法 |  | 
| G1| 充分利用cpu,分代收集，使用标记整理算法，可预测的停顿 ||

>并行(Parallel)：多条垃圾收集线程并行工作，但此时用户线程扔处于等待状态
>并发(Concurrent): 用户线程和垃圾收集线程同时执行。