# 类加载机制
***
## 类加载过程
JVM类加载过程分为5个步骤：加载、验证、准备、解析、初始化。

### 加载
- 什么时候才能加载：使用new关键字实例化对象，读取或设置一个类的静态字段（被final修饰过的静态字段除外，因为已经在编译期把结果放入常量池),调用一个类的静态方法，使用reflect对类进行反射调用的时候，初始化的该类有父类先初始化父类，包含main方法的那个类，使用JDK1.7动态语言的情况。
- 加载的过程：首先获取二进制字节流，然后转化为方法区的内存结构，最后内存中（没有指定是方法区还是堆）实例化一个该类的Class对象，作为方法区该类各种数据的访问入口。
### 验证
这一阶段的主要目的是为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
### 准备
该阶段为类变量设置初始值（不包括实例变量），且这里的初始值通常是数据类型的零值。
```
public static int v = 8080;
```
实际上是0,8080要在初始化阶段进行。
```
public static final int v = 8080;
```
特殊情况，编译时javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123
### 解析
将虚拟机常量池中的符号引用替换为直接引用。
- 符号引用：以一组符号描述所引用的目标，与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。
- 直接引用：直接引用可以是直接指向目标的指针、相对偏移量、句柄，直接引用和虚拟机实现的内存布局有关，如果有直接引用那么引用的目标在内存中一定存在。
### 初始化
真正开始执行java代码的阶段，初始化过程是执行java类构造器(clinit)方法的过程
## 类加载器
类加载器实现类的加载作用。JVM提供了三种类加载。
- 启动类加载器(BootStrap ClassLoader)：加载JAVA_HOME\lib目录中的指定类库如rt.jar，不符合规范的类库不会被加载。
- 扩展类加载器(Extension ClassLoader): 负责加载JAVA_HOME\lib\ext目录中的，或通过java.ext.dirs系统变量指定路径中的类库。
- 应用程序类加载器(Application ClassLoader): 负责加载用户路径(classpath)上的类库。
加载器之间的关系如下图所示，称之为双亲委派模型。
![Alt text](/pic/d330251551f6de988239494ce2773095.png)

### 双亲委派模型
如果一个类加载收到一个类加载请求，它首先不会自己加载该类，而是把请求传递给父类加载器，每个层次的类加载器都是如此，因此所有类加载请求都会由顶层的启动类加载器首先加载，只有当父类加载器反馈无法完成加载请求时，子类加载器才会尝试自己去加载。
### 破坏双亲委派模型
有的时候需要破坏双亲委派模型，1.向前兼容。2.JNDI服务如JDBC,解决方法引入线程上下文类加载器，可以自定义类加载器。3.热部署，直接更换成自定义的类加载。
