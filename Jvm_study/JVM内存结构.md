# JVM内存结构
***
## JDK和JRE
JDK是支持java程序开发的最小环境,JRE是支持java程序运行的标准环境。

## JVM内存模型
JVM内存大体上可以分为四个部门，程序记数器、栈(Stack)、堆(Heap)、方法区(Method Area)

### 程序计数器
程序计数器是线程私有的区域，每个线程都有一个计数器记录当前执行到哪个指令。这个计数器记录的是正在执行虚拟机字节码指令地址。**该区域是JVM规范唯一没有规定OutofMemory的区域。**

### 栈
栈内存分为本地方法栈和虚拟机栈，两者区别在于虚拟机栈用于执行native方法。该区域也是线程私有的，生命周期和线程相同。栈中存放的元素叫栈帧。而栈帧中存放了一些具体的数据，有局部变量表、操作数栈、动态链接、方法返回地址等。

![Alt text](/pic/z2EFBnN.png)

- 局部变量表：存放方法参数和方法内定义的局部变量
- 操作数栈：进行运算的存储空间，在方法执行的过程中，会有各种字节码指向操作数栈中写入和提取值。
- 动态链接：字节码中的方法调用指令就是以常量池中指向方法的符号引用为参数。可以说是以符号的形式代替方法的引用。
- 方法返回地址：方法正常退出时，保存的是pc计数器值即作为返回地址。当方法遇到异常时，需要由异常处理器来决定返回地址。此时栈帧保存该信息。

### 堆
存放所有实例对象,可以细分为新生代和老年代，新生代又可细分为eden、from survivor、to survivor三个区域。默认内存分配比例，如图所示。即young:old=1:2，eden:from:to=8:1:1。

![Alt text](/pic/duineicun2.png)

大多数情况下，对象在新生代eden区中分配，当eden区没有足够空间进行分配时，虚拟机将发起一次minor GC。而大对象直接进入老年代。

### 方法区
方法区和堆一样一样，是线程共享的区域，通常存储已被虚拟机加载的类信息、常量、静态变量。

## 常见异常和所使用调参方法

| 异常位置 | 异常类型 | 异常描述 | 常用调参 |
| ------ | ------ | ------ | ------|
| 堆 | OutofMemory:Java heap space  | 内存泄漏：没有自动回收泄漏对象例如流对象未关闭<br>内存溢出：对象所占内存过大 | -Xms:调整堆的初始大小<br>-Xmx:调整堆的最大上限 |
| 栈 | StackOverflowError<br> OutofMemoryError: unable to create new native thread | 栈深度超过最大深度:递归<br>栈内存不足:不断建立线程 | -Xss:调整栈容量大小 |
| 方法区 | OutofMemory: PermGen space | 内存溢出：存放了大量的类 | -XX:PermSize: 非堆内存初始大小<br>-XX:MaxPermSize：非堆内存最大上限 |

## 虚拟机中对象的分配、布局和访问

### 分配
对象在虚拟机中的布局有两种形式:**指针碰撞**、**空闲列表**。这个是由使用垃圾收集器的类别来决定。
- 指针碰撞:如果java堆中内存规整，将指针在空闲空间挪动一段与对象大小相等距离来分配内存。
- 空闲列表:如果java堆中内存不规整,虚拟机就必须中维护了一个列表，记录了哪些内存已用，哪些还未使用。分配内存时就得从列表中找到足够大的空间划给对象。

### 布局
对象在内存中存储的布局可以分为3块区域：对象头、实例数据、对象填充。对象头包括两部分信息，第一部分存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。另一部分是类型指针，虚拟机需要通过这个指针来确定这个对象是哪个类的实例。

### 访问
主流有**句柄**和**直接指针**两种。
- 句柄：堆中将划分一块内存存放句柄池，句柄中包含了两个指针，一个是实例数据的指针，另一个是类型数据的指针。好处是当对象被移动时只需要修改地址。
- 直接指针: 与句柄的区别在于实例数据不由指针维护，实例数据与类型数据指针在一个位置，好处在于减少一次指针定位的时间开销。