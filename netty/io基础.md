# io基础

## io 模型
- 1.阻塞io模型：最常用的io模型就是阻塞io模型，缺省情况下，所有文件操作都是阻塞的。在进程空间中调用recvfrom，其系统调用直到数据包到达且被复制到应用进程的缓冲区或者发生错误时才返回，在此期间一直会等待。
- 2.非阻塞io模型：如果缓冲区没数据的话，直接返回错误。一般都会轮询检查状态。
- 3.io复用模型：使用select/poll，顺序扫描fd是否就绪。epoll使用基于事件驱动方式代替顺序扫描，因此性能更高。当fd就绪时，立即回调函数rollback。
- 4.信号驱动io模型：通过信号回调通知应用程序调用recvfrom来读取数据
- 5.异步io：告知内核内核启动某个操作，并让内核在整个操作完成后（包括将数据从内核复制到用户自己的缓冲区）通知我们。

## 趣谈io模型
- 1.阻塞io模型: 老李去火车站买票，排队三天买到一张退票。耗费：在火车站吃喝拉撒睡3天，其他事一件没干。
- 2.非阻塞io模型：老李去火车站买票，隔12小时去火车站问有没有退票，三天后买到一张票。耗费：往返车站6次，路上6小时，其他时间做了好多事。
- 3.io复用模型：**(1)select/poll**老李去火车站买票，委托黄牛，然后每隔6小时电话黄牛询问，黄牛三天内买到票，然后老李去火车站交钱领票。**(2)epoll**老李去火车站买票，委托黄牛，黄牛买到后即通知老李去领，然后老李去火车站交钱领票。耗费：往返车站2次，路上2小时，黄牛手续费100元，无需打电话。
- 4.信号驱动io模型:老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李，然后老李去火车站交钱领票。耗费：往返车站2次，路上2小时，免黄牛费100元，无需打电话。
- 5.异步io模型:老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李并快递送票上门。耗费：往返车站1次，路上1小时，免黄牛费100元，无需打电话。

## io多路复用的实现方式:select、poll、epoll
- select:缺点：两次拷贝耗时，轮询所有fd耗时，支持的文件描述符太小。优点：跨平台支持。
- poll:缺点：大量拷贝，水平触发（当报告了fd没有被处理。会重复报告，很耗性能）。优点：连接数（也就是文件描述符）没有限制（链表存储）。
- epoll: 优点：没有最大并发连接的限制，只有活跃可用的fd才会调用callback函数，内存拷贝是利用mmap()文件映射内存的方式加速与内核空间的消息传递，减少复制开销。（内核与用户空间共享一块内存）。只有存在大量的空闲连接和不活跃的连接的时候，使用epoll的效率才会比select/poll高。LT：延迟处理，当检测到描述时间通知应用程序，应用程序不立即处理改事件。那么下次会再次通知应用程序此时间。ET:立即处理，当检测到描述符时间通知应用程序，应用程序会立即处理。具体ET和LT模式的分析：https://www.cnblogs.com/lojunren/p/3856290.html

## epoll底层实现原理
### epoll相关方法
- 新建epoll描述符==epoll_create()
- epoll_ctrl(epoll描述符，添加或者删除所有待监控的连接)
- 返回的活跃连接 ==epoll_wait（ epoll描述符 ）
### epoll的三大关键要素:**mmap、红黑树、链表**
epoll是通过内核与用户空间mmap同一块内存实现的。mmap将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址（不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射到物理地址），使得这块物理内存对内核和对用户均可见，减少用户态和内核态之间的数据交换。内核可以直接看到epoll监听的句柄，效率高。
红黑树将存储epoll所监听的套接字。上面mmap出来的内存如何保存epoll所监听的套接字，必然也得有一套数据结构，epoll在实现上采用红黑树去存储所有套接字，当添加或者删除一个套接字时（epoll_ctl），都在红黑树上去处理，红黑树本身插入和删除性能比较好，时间复杂度O(logN)。
### 添加以及返回事件
通过epoll_ctl函数添加进来的事件都会被放在红黑树的某个节点内，所以，重复添加是没有用的。当把事件添加进来的时候时候会完成关键的一步，那就是该事件都会与相应的设备（网卡）驱动程序建立回调关系，当相应的事件发生后，就会调用这个回调函数，该回调函数在内核中被称为：ep_poll_callback,这个回调函数其实就所把这个事件添加到rdllist这个双向链表中。一旦有事件发生，epoll就会将该事件添加到双向链表中。那么当我们调用epoll_wait时，epoll_wait只需要检查rdlist双向链表中是否有存在注册的事件，效率非常可观。这里也需要将发生了的事件复制到用户态内存中即可。
![Alt text](/pic/270055452951970.jpg)
### epoll_wait的工作流程
- epoll_wait调用ep_poll，当rdlist为空（无就绪fd）时挂起当前进程，直到rdlist不空时进程才被唤醒。
- 文件fd状态改变（buffer由不可读变为可读或由不可写变为可写），导致相应fd上的回调函数ep_poll_callback()被调用。
- ep_poll_callback将相应fd对应epitem加入rdlist，导致rdlist不空，进程被唤醒，epoll_wait得以继续执行。
- ep_events_transfer函数将rdlist中的epitem拷贝到txlist中，并将rdlist清空。
- ep_send_events函数（很关键），它扫描txlist中的每个epitem，调用其关联fd对用的poll方法。此时对poll的调用仅仅是取得fd上较新的events（防止之前events被更新），之后将取得的events和相应的fd发送到用户空间（封装在struct epoll_event，从epoll_wait返回）。  
