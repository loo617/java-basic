# 线程同步机制
***

## 锁的概述
是一种对共享数据进行保障的技术，保证线程需要持有许可才能访问共享数据。

## 锁的特性
### 互斥性
所谓互斥性指的是一个锁只能被一个线程持有，这种特性使得锁具备了原子性、同时锁的获得隐含着刷新处理器缓存这个动作因此保障了可见性。同时锁还能够保障有序性。

### 可重入性
重入锁的实现为ReentrantLock类，所谓可重入是指当前线程可以进入它已拥有锁的同步代码块。

### 调度
锁的调用策略有公平策略和非公平策略，内部锁属于非公平锁，而显式锁既支持公平锁又支持非公平锁。非公平锁的性能要高于公平锁，且能充分利用cpu的时间片。如果业务中线程占用时间长于线程等待，此时更倾向于使用公平锁。使用公平锁的话会导致饥饿现象。

## 锁的分类
- 内部锁：使用synchronized实现，锁句柄通常采用private final修饰，内部锁的使用不会导致锁泄漏简单易用，但不灵活无法跨方法。
- 显示锁：Lock接口实例，支持tryLock方法，通过Thread dump可以定位线程问题。由于是面向对象的形式所以使用灵活，但可能会产生锁泄漏所以需要释放锁。

## 其他同步机制
- volatile：轻量级的同步机制，用于修饰共享可变变量。作用是保障可见性、有序性、和long\double型变量读写操作的原子性。性能开销小代码简单适用于状态标志位。
- CAS：CAS（compare and swap)用来保障read-modify-write更新操作，由于volatile并不能保障count++的原子性，所以需要引用原子变量类(Atomics)，该类可以看成是增强型的volatile变量。
- static：保证一个线程即使在未使用其他同步机制时总能读取类静态变量的初始值。
- final：保证该字段所引用的对象初始化完毕，即读取到字段的初始值而不是默认值。

## 对象发布技术